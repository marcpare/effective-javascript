Item 1: Know which Javascript you are using
---

- Concatenating strict and non-strict Javascript files is potentially problematic
- Can be avoided with Immediately Invoked Functions

Item 2: Understand Javascript's Floating-Point Numbers
---

- Javascript only has doubles
- So, of course, be careful with the accuracy

Item 3: Beware of implicit coercions
---

- Javascript will often perform an implicit type coercion rather than throw an error, which will hide bugs until downstream

- NaN is really weird:

var x = NaN;
x === NaN; // false!

isNaN(NaN) // true, but so is...
isNaN("foo")
isNaN(undefined)
isNaN({})

idiom is: `x !== x`

_truthiness_ as a coercion. 

if (!x) // what if x = 0, false, NaN, or null?

instead, use

`if (typeof x === undefined)`

Item 4: Prefer primitives to object wrappers
---

Don't set properties on primitive types (it does nothing)

Item 5: Avoid using == with mixed types
---

Convert a string to a number:

`+form.month.value`

Strict equals `===`

Item 6: Learn the limits of semicolon insertion
---

Semicolons are inserted...

- Before a } token
- After on or more newlines
- At the end of the program input
- Only when the next input token cannot be parsed

A hairy example:

a = b
(f());

parses as

a = b(f());

Characters that will result in this tricky situation: (, [, +, -, /

A nifty idiom for testing regular expressions:

/Error/i.test(str) && fail() // fail executed if Error is found in str

Item 7: Think of string as sequences of 16-bit code units
---





Item 30: prototype, getPrototypeOf, and __proto__

Item 31: prefer Object.getPrototypeOf to __proto__

Item 52: convert Array-like object to an array:

[].slice.call(arraylike)

Chapter 6: Library and API Design
---

Elements of the challenge to API Design

* Users of your code have to learn to read and write it.
* Unexpected inputs combinations to API functions
* 

Item 53: Maintain Consistent Conventions

"Your users will thank you. Or maybe they won't even notice--so much the better!"
"pick a naming convention and adhere to it religiously"

"A great library treats its documentation as training wheels. Once your users get accustomed to your library's conventions, they should be able to do common tasks without ever checking the documentation."

Item 54: Treat Undefined as "no value"

Don't give undefined other semantics. Example given is to use it to mean "give me a random color".

Checking for a defined argument

`
function Server(port, hostname) {
  if (hostname === undefined){
    //...
  }
}
`

Can also use a logical operator

hostname = String(hostname || "localhost");

This latter form doesn't work is `hostname = 0` is valid.

Checking arguments.length is buggy if `undefined` is passed as an argument. It will count the `undefined` argument.

Item 55: Accept Options objects for keyword arguments

"argument creep": slowly adding arguments to a function until it has a dozen (or more!)

`
alert = new Alert({
  x:100, y:75, width: 300, etc...
})
`

Implementing it:

function Alert(parent, message, opts){
  opts = opts || {};
  this.width = opts.width === undefined ? 320 : opts.width; // in case 0
  this.color = opts.color || "red";
  this.modal = !!ops.modal; //coerce to boolean
}

Using `extend` 

opts = extend({
  width: 320,
  height: 640
}, opts); // I caught the errata

A different check for undefined, which avoids a ReferenceEffort if the variable isn't defined.

`
if (typeof val !== "undefined") {
}
`

Item 56: Avoid unnecessary state
---

"To understand what any individual call to `fillText` does, you don't have to understand all the modifications that precede it."

Item 57: Use structural typing for flexible interfaces
---

"It is often perfectly sufficient to provide an implementation for an interface like the MediaWiki page format with a simple object literal"

Structural typing: "any object will do so long as it has the expected structure"

Item 58: Distinguish between Array and Array-like
---

Test if something is a number: 

`typeof x === "number"`

"There may be multiple copies of the standard Array constructor and prototype object" WHAT?!

`
toString = Object.prototype.toString;
toString.call(x) === '[object Array]
`

"Never overload structural types with other overlapping types"

Item 59: Avoid Excessive Coercion
---

Relying on type-coercion leads to difficult-to-diagnose bugs.

Item 60: Support method chaining
---

Eliminating temporary variables makes it clearer to readers of the code that the intermediate results are only important as a step along the way to the final result.

Stateful APIs of the _fluent style_ simulate smalltalk's 'method cascades'

Item 61: Don't Block the event queue on I/O
---

Basically, don't use synchronous calls (which isn't good style anyway)

Item 62: Use nested or named callback for asynchronous sequencing
---

You "lift" nested callbacks by naming them.

Shows use of bind to partially apply a function.

Item 63: Be aware of dropped errors
---

Drop the convention of using curly braces in your if statements for cleaner error handling

`if (error) return onError(error);`

Item 64: Use recursion for asynchronous loops
---

Example doesn't blow the call stack.

Item 65: Don't block the event queue on computation
---

Shows the Worker API.
Can spawn a webworker and post messages back and forth.

Uses a recursive function and `setTimeout` to avoid blocking the event queue on a long-running loop.

Item 66: Use a counter to perform concurrent operations
---

Long discussion of a fairly obvious consequence of async function calls: you can't be sure what order they'll return in.

Item 67: Never call asynchronous callback synchronously
---

When returning a value from an asynchronous function, use `setTimeout` (or another async call) to avoid surprising clients of the API.

`setTimeout(onsucccess.bind(null, cached), 0);`

[] is truthy

Item 68: Use promises for clean asynchronous logic
---

Promises avoid modifying shared data.

You can race promises against each other with `select`






















